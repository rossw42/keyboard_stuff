/**
 * SCAD to Ergogen Converter
 * Converts SCAD output from hotswap_pcb_generator to Ergogen YAML format
 */

const fs = require('fs').promises;
const yaml = require('js-yaml');
const { evaluateSCAD } = require('./scadEvaluator');

/**
 * Parse SCAD layout file generated by hotswap_pcb_generator
 * @param {string} scadFilePath - Path to the SCAD file
 * @returns {Object} Parsed layout data
 */
async function parseSCADLayout(scadFilePath) {
    try {
        const path = require('path');
        
        // Get paths to parameter files (always use KLE_SCAD_Ergogen/scad directory)
        const scadDir = path.join(__dirname, '..', 'scad');
        const parametersPath = path.join(scadDir, 'parameters.scad');
        const stabilizersPath = path.join(scadDir, 'stabilizer_spacing.scad');
        
        // Use proper SCAD evaluation
        const evaluatedData = await evaluateSCAD(parametersPath, stabilizersPath, scadFilePath);
        
        return {
            switches: evaluatedData.switches,
            stabilizers: evaluatedData.stabilizers,
            metadata: {
                name: 'SCAD Import',
                keyCount: evaluatedData.switches.length,
                unit: evaluatedData.metadata.unit,
                switchType: evaluatedData.metadata.switchType
            }
        };
        
    } catch (error) {
        throw new Error(`Failed to parse SCAD file: ${error.message}`);
    }
}

/**
 * Parse a SCAD array string into JavaScript objects
 * @param {string} arrayStr - SCAD array string
 * @returns {Array} Parsed array of objects
 */
function parseSCADArray(arrayStr) {
    const items = [];
    
    // Split by lines and clean up
    const lines = arrayStr.split('\n')
        .map(line => line.trim())
        .filter(line => line && !line.startsWith('//'));
    
    for (const line of lines) {
        if (line.includes('[')) {
            try {
                // Convert SCAD format to JSON-compatible format
                let jsonStr = line.replace(/,$/, ''); // Remove trailing comma
                
                // Handle unit expressions like "1+0.625*unit*mm"
                jsonStr = jsonStr.replace(/(\d+(?:\.\d+)?)\+(\d+(?:\.\d+)?)\*unit\*mm/g, 
                    (match, base, mult) => {
                        // Convert to numeric value (assuming unit = 19.05mm)
                        return (parseFloat(base) + parseFloat(mult) * 19.05).toString();
                    });
                
                // Handle other unit expressions
                jsonStr = jsonStr.replace(/unit\*mm/g, '19.05');
                
                // Handle unquoted identifiers like stab_6_25u by adding quotes
                jsonStr = jsonStr.replace(/,([a-zA-Z_][a-zA-Z0-9_]*)\]/g, ',"$1"]');
                jsonStr = jsonStr.replace(/,([a-zA-Z_][a-zA-Z0-9_]*),/g, ',"$1",');
                
                const parsed = JSON.parse(jsonStr);
                items.push(parsed);
            } catch (error) {
                console.warn(`Failed to parse SCAD line: ${line}`, error);
            }
        }
    }
    
    return items;
}

/**
 * Extract metadata from SCAD comments
 * @param {string} scadContent - SCAD file content
 * @returns {Object} Metadata object
 */
function extractMetadata(scadContent) {
    const metadata = {};
    
    // Extract layout name from comments
    const nameMatch = scadContent.match(/\/\/.*layout:\s*(.+)/i);
    if (nameMatch) {
        metadata.name = nameMatch[1].trim();
    }
    
    // Extract key count
    const keyMatch = scadContent.match(/\/\/.*keys:\s*(\d+)/i);
    if (keyMatch) {
        metadata.keyCount = parseInt(keyMatch[1]);
    }
    
    return metadata;
}

/**
 * Convert SCAD layout data to Ergogen YAML format
 * @param {Object} scadData - Parsed SCAD data
 * @param {Object} options - Conversion options
 * @returns {string} Ergogen YAML configuration
 */
function convertToErgogen(scadData, options = {}) {
    const {
        switchType = 'mx',
        keySpacing = 19,
        includeOutlines = true,
        includePCB = false,
        includeCase = false
    } = options;
    
    // Process switches into Ergogen points format
    const points = generateErgogenPoints(scadData.switches, options);
    
    const config = {
        meta: {
            engine: 'v4',
            name: scadData.metadata.name || 'SCAD Import',
            version: '1.0',
            author: 'SCAD to Ergogen Converter',
            url: ''
        },
        
        units: {
            kx: keySpacing,
            ky: keySpacing,
            px: 2,
            py: 2,
            keycap: 18,
            switch: 14
        },
        
        points,
        
        outlines: includeOutlines ? generateOutlines() : {},
        pcbs: includePCB ? generatePCB(options) : {},
        cases: includeCase ? generateCase() : {}
    };
    
    return yaml.dump(config, {
        indent: 2,
        lineWidth: 120,
        noRefs: true
    });
}

/**
 * Generate Ergogen points from SCAD switch data
 * @param {Array} switches - SCAD switch array
 * @param {Object} options - Generation options
 * @returns {Object} Ergogen points configuration
 */
function generateErgogenPoints(switches, options = {}) {
    // Convert SCAD format to key objects
    const keys = switches.map((switchData, index) => {
        const [locationData, borderData, extraData] = switchData;
        const [position, keySize, rotation] = locationData;
        
        return {
            id: `key_${index}`,
            x: position[0],
            y: position[1],
            width: keySize,
            height: 1, // SCAD format doesn't store height separately
            rotation: {
                angle: rotation[0],
                centerX: rotation[1],
                centerY: rotation[2]
            },
            borders: borderData
        };
    });
    
    // Group keys into columns
    const columns = groupIntoColumns(keys);
    
    const zones = {
        matrix: {
            key: {},
            columns: {}
        }
    };
    
    // Convert to Ergogen format
    Object.entries(columns).forEach(([colName, colKeys]) => {
        const column = {
            key: {},
            rows: {}
        };
        
        colKeys.forEach((key, rowIndex) => {
            const rowName = `row${rowIndex}`;
            const row = {
                shift: [key.x * 19.05, key.y * 19.05]
            };
            
            // Add rotation if present
            if (key.rotation.angle !== 0) {
                row.rotate = key.rotation.angle;
            }
            
            // Add size if not standard
            if (key.width !== 1) {
                row.width = key.width;
            }
            
            column.rows[rowName] = row;
        });
        
        zones.matrix.columns[colName] = column;
    });
    
    return {
        zones,
        key: {
            padding: 'ky',
            spread: 'kx'
        }
    };
}

/**
 * Group keys into columns based on X position
 * @param {Array} keys - Array of key objects
 * @returns {Object} Keys grouped by columns
 */
function groupIntoColumns(keys) {
    const columns = {};
    const tolerance = 0.5; // Half unit tolerance
    
    // Get unique X positions
    const xPositions = [];
    keys.forEach(key => {
        const x = key.x;
        let found = false;
        for (let i = 0; i < xPositions.length; i++) {
            if (Math.abs(xPositions[i] - x) < tolerance) {
                found = true;
                break;
            }
        }
        if (!found) {
            xPositions.push(x);
        }
    });
    
    xPositions.sort((a, b) => a - b);
    
    // Group keys by column
    xPositions.forEach((xPos, index) => {
        const colName = `col${index}`;
        columns[colName] = [];
        
        keys.forEach(key => {
            if (Math.abs(key.x - xPos) < tolerance) {
                columns[colName].push(key);
            }
        });
        
        // Sort by Y position
        columns[colName].sort((a, b) => b.y - a.y);
    });
    
    return columns;
}

/**
 * Generate basic outlines
 * @returns {Object} Outlines configuration
 */
function generateOutlines() {
    return {
        plate: [
            {
                what: 'rectangle',
                where: true,
                size: [14, 14],
                fillet: 0.5
            }
        ],
        pcb: [
            {
                what: 'rectangle', 
                where: true,
                size: [18, 18],
                fillet: 2,
                expand: 5
            }
        ]
    };
}

/**
 * Generate PCB configuration
 * @param {Object} options - PCB options
 * @returns {Object} PCB configuration
 */
function generatePCB(options = {}) {
    const {
        switchType = 'mx',
        hotswap = true,
        microcontroller = 'promicro'
    } = options;
    
    return {
        main: {
            outlines: {
                main: {
                    outline: 'pcb'
                }
            },
            footprints: {
                switches: {
                    what: switchType,
                    where: true,
                    params: {
                        hotswap,
                        reverse: false,
                        keycaps: true,
                        from: '{{column_net}}',
                        to: '{{row_net}}'
                    }
                },
                diodes: {
                    what: 'diode',
                    where: true,
                    params: {
                        from: '{{row_net}}',
                        to: '{{column_net}}'
                    },
                    adjust: {
                        shift: [0, -5]
                    }
                },
                mcu: {
                    what: microcontroller,
                    where: {
                        ref: 'matrix',
                        shift: [0, -30]
                    },
                    params: {
                        orientation: 'down'
                    }
                }
            }
        }
    };
}

/**
 * Generate case configuration
 * @returns {Object} Case configuration
 */
function generateCase() {
    return {
        bottom: {
            what: 'outline',
            name: 'pcb', 
            extrude: 5,
            expand: 2,
            fillet: 3
        },
        plate: {
            what: 'outline',
            name: 'plate',
            extrude: 1.5
        }
    };
}

module.exports = {
    parseSCADLayout,
    convertToErgogen,
    parseSCADArray,
    extractMetadata,
    generateErgogenPoints,
    groupIntoColumns
};